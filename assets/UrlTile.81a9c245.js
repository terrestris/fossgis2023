import{C as Ee}from"./featureloader.66bc25dd.js";import{l as ve,m as Fe,I as Le,R as de,a as Ue,n as Ie,o as J,k as Pe}from"./TileEventType.49efe80f.js";import{aY as ze,C as De,az as Se,aP as L,e as ge,h as je,U as Ae,j as be,k as Oe,f as Te,g as Ke,aZ as pe,y as S,m as fe,o as _e,n as Ze,aB as Me,R as Ye,p as ke,w as Xe}from"./Source.c163b9e6.js";function Ge(T,e){const t=/\{z\}/g,i=/\{x\}/g,n=/\{y\}/g,o=/\{-y\}/g;return function(a,r,f){if(!!a)return T.replace(t,a[0].toString()).replace(i,a[1].toString()).replace(n,a[2].toString()).replace(o,function(){const s=a[0],u=e.getFullTileRange(s);return De(u,55),(u.getHeight()-a[2]-1).toString()})}}function qe(T,e){const t=T.length,i=new Array(t);for(let n=0;n<t;++n)i[n]=Ge(T[n],e);return Ne(i)}function Ne(T){return T.length===1?T[0]:function(e,t,i){if(!e)return;const n=ve(e),o=ze(n,T.length);return T[o](e,t,i)}}function Be(T){const e=[];let t=/\{([a-z])-([a-z])\}/.exec(T);if(t){const i=t[1].charCodeAt(0),n=t[2].charCodeAt(0);let o;for(o=i;o<=n;++o)e.push(T.replace(t[0],String.fromCharCode(o)));return e}if(t=/\{(\d+)-(\d+)\}/.exec(T),t){const i=parseInt(t[2],10);for(let n=parseInt(t[1],10);n<=i;n++)e.push(T.replace(t[0],n.toString()));return e}return e.push(T),e}class Qe extends Ee{constructor(e){super(e),this.extentChanged=!0,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedRevision,this.renderedTiles=[],this.newTiles_=!1,this.tmpExtent=Se(),this.tmpTileRange_=new Fe(0,0,0,0)}isDrawableTile(e){const t=this.getLayer(),i=e.getState(),n=t.getUseInterimTilesOnError();return i==L.LOADED||i==L.EMPTY||i==L.ERROR&&!n}getTile(e,t,i,n){const o=n.pixelRatio,a=n.viewState.projection,r=this.getLayer();let s=r.getSource().getTile(e,t,i,o,a);return s.getState()==L.ERROR&&r.getUseInterimTilesOnError()&&r.getPreload()>0&&(this.newTiles_=!0),this.isDrawableTile(s)||(s=s.getInterimTile()),s}getData(e){const t=this.frameState;if(!t)return null;const i=this.getLayer(),n=ge(t.pixelToCoordinateTransform,e.slice()),o=i.getExtent();if(o&&!je(o,n))return null;const a=t.pixelRatio,r=t.viewState.projection,f=t.viewState,s=i.getRenderSource(),u=s.getTileGridForProjection(f.projection),l=s.getTilePixelRatio(t.pixelRatio);for(let p=u.getZForResolution(f.resolution);p>=u.getMinZoom();--p){const d=u.getTileCoordForCoordAndZ(n,p),c=s.getTile(p,d[1],d[2],a,r);if(!(c instanceof Le||c instanceof de)||c instanceof de&&c.getState()===L.EMPTY)return null;if(c.getState()!==L.LOADED)continue;const C=u.getOrigin(p),w=Ae(u.getTileSize(p)),R=u.getResolution(p),x=Math.floor(l*((n[0]-C[0])/R-d[1]*w[0])),E=Math.floor(l*((C[1]-n[1])/R-d[2]*w[1])),g=Math.round(l*s.getGutterForProjection(f.projection));return this.getImageData(c.getImage(),x+g,E+g)}return null}loadedTileCallback(e,t,i){return this.isDrawableTile(i)?super.loadedTileCallback(e,t,i):!1}prepareFrame(e){return!!this.getLayer().getSource()}renderFrame(e,t){const i=e.layerStatesArray[e.layerIndex],n=e.viewState,o=n.projection,a=n.resolution,r=n.center,f=n.rotation,s=e.pixelRatio,u=this.getLayer(),l=u.getSource(),p=l.getRevision(),d=l.getTileGridForProjection(o),c=d.getZForResolution(a,l.zDirection),C=d.getResolution(c);let w=e.extent;const R=e.viewState.resolution,x=l.getTilePixelRatio(s),E=Math.round(be(w)/R*s),g=Math.round(Oe(w)/R*s),U=i.extent&&Te(i.extent,o);U&&(w=Ke(w,Te(i.extent,o)));const v=C*E/2/x,te=C*g/2/x,_=[r[0]-v,r[1]-te,r[0]+v,r[1]+te],G=d.getTileRangeForExtentAndZ(w,c),Z={};Z[c]={};const ie=this.createLoadedTileFinder(l,o,Z),ne=this.tmpExtent,oe=this.tmpTileRange_;this.newTiles_=!1;const xe=f?pe(n.center,R,f,e.size):void 0;for(let D=G.minX;D<=G.maxX;++D)for(let y=G.minY;y<=G.maxY;++y){if(f&&!d.tileCoordIntersectsViewport([c,D,y],xe))continue;const m=this.getTile(c,D,y,e);if(this.isDrawableTile(m)){const b=S(this);if(m.getState()==L.LOADED){Z[c][m.tileCoord.toString()]=m;let O=m.inTransition(b);O&&i.opacity!==1&&(m.endTransition(b),O=!1),!this.newTiles_&&(O||!this.renderedTiles.includes(m))&&(this.newTiles_=!0)}if(m.getAlpha(b,e.time)===1)continue}const H=d.getTileCoordChildTileRange(m.tileCoord,oe,ne);let Y=!1;H&&(Y=ie(c+1,H)),Y||d.forEachTileCoordParentTileRange(m.tileCoord,ie,oe,ne)}const q=C/a*s/x;fe(this.pixelTransform,e.size[0]/2,e.size[1]/2,1/s,1/s,f,-E/2,-g/2);const Q=_e(this.pixelTransform);this.useContainer(t,Q,this.getBackground(e));const h=this.context,j=h.canvas;Ze(this.inversePixelTransform,this.pixelTransform),fe(this.tempTransform,E/2,g/2,q,q,0,-E/2,-g/2),j.width!=E||j.height!=g?(j.width=E,j.height=g):this.containerReused||h.clearRect(0,0,E,g),U&&this.clipUnrotated(h,e,U),l.getInterpolate()||(h.imageSmoothingEnabled=!1),this.preRender(h,e),this.renderedTiles.length=0;let M=Object.keys(Z).map(Number);M.sort(Me);let A,V,I;i.opacity===1&&(!this.containerReused||l.getOpaque(e.viewState.projection))?M=M.reverse():(A=[],V=[]);for(let D=M.length-1;D>=0;--D){const y=M[D],m=l.getTilePixelSize(y,s,o),Y=d.getResolution(y)/C,b=m[0]*Y*q,O=m[1]*Y*q,$=d.getTileCoordForCoordAndZ(Ye(_),y),se=d.getTileCoordExtent($),N=ge(this.tempTransform,[x*(se[0]-_[0])/C,x*(_[3]-se[3])/C]),Re=x*l.getGutterForProjection(o),re=Z[y];for(const ye in re){const K=re[ye],le=K.tileCoord,ae=$[1]-le[1],me=Math.round(N[0]-(ae-1)*b),ce=$[2]-le[2],Ce=Math.round(N[1]-(ce-1)*O),P=Math.round(N[0]-ae*b),z=Math.round(N[1]-ce*O),k=me-P,X=Ce-z,he=c===y,ue=he&&K.getAlpha(S(this),e.time)!==1;let W=!1;if(!ue)if(A){I=[P,z,P+k,z,P+k,z+X,P,z+X];for(let B=0,we=A.length;B<we;++B)if(c!==y&&y<V[B]){const F=A[B];ke([P,z,P+k,z+X],[F[0],F[3],F[4],F[7]])&&(W||(h.save(),W=!0),h.beginPath(),h.moveTo(I[0],I[1]),h.lineTo(I[2],I[3]),h.lineTo(I[4],I[5]),h.lineTo(I[6],I[7]),h.moveTo(F[6],F[7]),h.lineTo(F[4],F[5]),h.lineTo(F[2],F[3]),h.lineTo(F[0],F[1]),h.clip())}A.push(I),V.push(y)}else h.clearRect(P,z,k,X);this.drawTileImage(K,e,P,z,k,X,Re,he),A&&!ue?(W&&h.restore(),this.renderedTiles.unshift(K)):this.renderedTiles.push(K),this.updateUsedTiles(e.usedTiles,l,K)}}return this.renderedRevision=p,this.renderedResolution=C,this.extentChanged=!this.renderedExtent_||!Xe(this.renderedExtent_,_),this.renderedExtent_=_,this.renderedPixelRatio=s,this.renderedProjection=o,this.manageTilePyramid(e,l,d,s,o,w,c,u.getPreload()),this.scheduleExpireCache(e,l),this.postRender(h,e),i.extent&&h.restore(),h.imageSmoothingEnabled=!0,Q!==j.style.transform&&(j.style.transform=Q),this.container}drawTileImage(e,t,i,n,o,a,r,f){const s=this.getTileImage(e);if(!s)return;const u=S(this),l=t.layerStatesArray[t.layerIndex],p=l.opacity*(f?e.getAlpha(u,t.time):1),d=p!==this.context.globalAlpha;d&&(this.context.save(),this.context.globalAlpha=p),this.context.drawImage(s,r,r,s.width-2*r,s.height-2*r,i,n,o,a),d&&this.context.restore(),p!==l.opacity?t.animate=!0:f&&e.endTransition(u)}getImage(){const e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}scheduleExpireCache(e,t){if(t.canExpireCache()){const i=function(n,o,a){const r=S(n);r in a.usedTiles&&n.expireCache(a.viewState.projection,a.usedTiles[r])}.bind(null,t);e.postRenderFunctions.push(i)}}updateUsedTiles(e,t,i){const n=S(t);n in e||(e[n]={}),e[n][i.getKey()]=!0}manageTilePyramid(e,t,i,n,o,a,r,f,s){const u=S(t);u in e.wantedTiles||(e.wantedTiles[u]={});const l=e.wantedTiles[u],p=e.tileQueue,d=i.getMinZoom(),c=e.viewState.rotation,C=c?pe(e.viewState.center,e.viewState.resolution,c,e.size):void 0;let w=0,R,x,E,g,U,v;for(v=d;v<=r;++v)for(x=i.getTileRangeForExtentAndZ(a,v,x),E=i.getResolution(v),g=x.minX;g<=x.maxX;++g)for(U=x.minY;U<=x.maxY;++U)c&&!i.tileCoordIntersectsViewport([v,g,U],C)||(r-v<=f?(++w,R=t.getTile(v,g,U,n,o),R.getState()==L.IDLE&&(l[R.getKey()]=!0,p.isKeyQueued(R.getKey())||p.enqueue([R,u,i.getTileCoordCenter(R.tileCoord),E])),s!==void 0&&s(R)):t.useTile(v,g,U,o));t.updateCacheSize(w,o)}}const We=Qe;class ee extends Ue{constructor(e){super({attributions:e.attributions,cacheSize:e.cacheSize,opaque:e.opaque,projection:e.projection,state:e.state,tileGrid:e.tileGrid,tilePixelRatio:e.tilePixelRatio,wrapX:e.wrapX,transition:e.transition,interpolate:e.interpolate,key:e.key,attributionsCollapsible:e.attributionsCollapsible,zDirection:e.zDirection}),this.generateTileUrlFunction_=this.tileUrlFunction===ee.prototype.tileUrlFunction,this.tileLoadFunction=e.tileLoadFunction,e.tileUrlFunction&&(this.tileUrlFunction=e.tileUrlFunction),this.urls=null,e.urls?this.setUrls(e.urls):e.url&&this.setUrl(e.url),this.tileLoadingKeys_={}}getTileLoadFunction(){return this.tileLoadFunction}getTileUrlFunction(){return Object.getPrototypeOf(this).tileUrlFunction===this.tileUrlFunction?this.tileUrlFunction.bind(this):this.tileUrlFunction}getUrls(){return this.urls}handleTileChange(e){const t=e.target,i=S(t),n=t.getState();let o;n==L.LOADING?(this.tileLoadingKeys_[i]=!0,o=J.TILELOADSTART):i in this.tileLoadingKeys_&&(delete this.tileLoadingKeys_[i],o=n==L.ERROR?J.TILELOADERROR:n==L.LOADED?J.TILELOADEND:void 0),o!=null&&this.dispatchEvent(new Ie(o,t))}setTileLoadFunction(e){this.tileCache.clear(),this.tileLoadFunction=e,this.changed()}setTileUrlFunction(e,t){this.tileUrlFunction=e,this.tileCache.pruneExceptNewestZ(),typeof t<"u"?this.setKey(t):this.changed()}setUrl(e){const t=Be(e);this.urls=t,this.setUrls(t)}setUrls(e){this.urls=e;const t=e.join(`
`);this.generateTileUrlFunction_?this.setTileUrlFunction(qe(e,this.tileGrid),t):this.setKey(t)}tileUrlFunction(e,t,i){}useTile(e,t,i){const n=Pe(e,t,i);this.tileCache.containsKey(n)&&this.tileCache.get(n)}}const Je=ee;export{We as C,Je as U,qe as c,Be as e};
