import{br as ce,au as le,p as de,b5 as ue,ca as fe,as as ge,cb as _e,cc as z,cd as Q,bp as J,ce as w,cf as M,cg as me,ch as H,ci as ye,cj as pe,ck as Ce,E as Z,cl as C,cm as we,aQ as G,cn as ee,aO as b,co as W,B as Te,aN as te,t as xe,bD as se,Q as q,aE as Pe,y as O,az as ke,l as P,u as j,bn as X,bj as Fe,al as De,cp as Ee,cq as Se,bP as Le,cr as Me,H as Ge,K as Re}from"./Source.c163b9e6.js";import{V as U,a as B,F as k,R as Ie,c as Y}from"./Vector.680108bb.js";import{a as ve,G as be}from"./GeoJSON.bf361bd3.js";import{L as R,a as Oe,b as ie,M as ne}from"./Feature.b6b724ef.js";import{m as je}from"./featureloader.66bc25dd.js";class I extends ce{constructor(e,t,s){super(),s!==void 0&&t===void 0?this.setFlatCoordinates(s,e):(t=t||0,this.setCenterAndRadius(e,t,s))}clone(){const e=new I(this.flatCoordinates.slice(),void 0,this.layout);return e.applyProperties(this),e}closestPointXY(e,t,s,i){const n=this.flatCoordinates,r=e-n[0],o=t-n[1],a=r*r+o*o;if(a<i){if(a===0)for(let h=0;h<this.stride;++h)s[h]=n[h];else{const h=this.getRadius()/Math.sqrt(a);s[0]=n[0]+h*r,s[1]=n[1]+h*o;for(let l=2;l<this.stride;++l)s[l]=n[l]}return s.length=this.stride,a}return i}containsXY(e,t){const s=this.flatCoordinates,i=e-s[0],n=t-s[1];return i*i+n*n<=this.getRadiusSquared_()}getCenter(){return this.flatCoordinates.slice(0,this.stride)}computeExtent(e){const t=this.flatCoordinates,s=t[this.stride]-t[0];return le(t[0]-s,t[1]-s,t[0]+s,t[1]+s,e)}getRadius(){return Math.sqrt(this.getRadiusSquared_())}getRadiusSquared_(){const e=this.flatCoordinates[this.stride]-this.flatCoordinates[0],t=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return e*e+t*t}getType(){return"Circle"}intersectsExtent(e){const t=this.getExtent();if(de(e,t)){const s=this.getCenter();return e[0]<=s[0]&&e[2]>=s[0]||e[1]<=s[1]&&e[3]>=s[1]?!0:ue(e,this.intersectsCoordinate.bind(this))}return!1}setCenter(e){const t=this.stride,s=this.flatCoordinates[t]-this.flatCoordinates[0],i=e.slice();i[t]=i[0]+s;for(let n=1;n<t;++n)i[t+n]=e[n];this.setFlatCoordinates(this.layout,i),this.changed()}setCenterAndRadius(e,t,s){this.setLayout(s,e,0),this.flatCoordinates||(this.flatCoordinates=[]);const i=this.flatCoordinates;let n=fe(i,0,e,this.stride);i[n++]=i[0]+t;for(let r=1,o=this.stride;r<o;++r)i[n++]=i[r];i.length=n,this.changed()}getCoordinates(){return null}setCoordinates(e,t){}setRadius(e){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+e,this.changed()}rotate(e,t){const s=this.getCenter(),i=this.getStride();this.setCenter(ge(s,0,s.length,i,e,t,s)),this.changed()}translate(e,t){const s=this.getCenter(),i=this.getStride();this.setCenter(_e(s,0,s.length,i,e,t,s)),this.changed()}}I.prototype.transform;const Ne=I,F={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class D extends Te{constructor(e,t){super(e),this.feature=t}}function Ae(c,e){const t=[];for(let s=0;s<e.length;++s){const n=e[s].getGeometry();re(c,n,t)}return t}function E(c,e){return se(c[0],c[1],e[0],e[1])}function T(c,e){const t=c.length;return e<0?c[e+t]:e>=t?c[e-t]:c[e]}function S(c,e,t){let s,i;e<t?(s=e,i=t):(s=t,i=e);const n=Math.ceil(s),r=Math.floor(i);if(n>r){const a=x(c,s),h=x(c,i);return E(a,h)}let o=0;if(s<n){const a=x(c,s),h=T(c,n);o+=E(a,h)}if(r<i){const a=T(c,r),h=x(c,i);o+=E(a,h)}for(let a=n;a<r-1;++a){const h=T(c,a),l=T(c,a+1);o+=E(h,l)}return o}function re(c,e,t){if(e instanceof R){L(c,e.getCoordinates(),!1,t);return}if(e instanceof ie){const s=e.getCoordinates();for(let i=0,n=s.length;i<n;++i)L(c,s[i],!1,t);return}if(e instanceof te){const s=e.getCoordinates();for(let i=0,n=s.length;i<n;++i)L(c,s[i],!0,t);return}if(e instanceof ne){const s=e.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length;o<a;++o)L(c,r[o],!0,t)}return}if(e instanceof ve){const s=e.getGeometries();for(let i=0;i<s.length;++i)re(c,s[i],t);return}}const N={index:-1,endIndex:NaN};function Ve(c,e,t,s){const i=c[0],n=c[1];let r=1/0,o=-1,a=NaN;for(let d=0;d<e.targets.length;++d){const u=e.targets[d],f=u.coordinates;let g=1/0,_;for(let m=0;m<f.length-1;++m){const y=f[m],p=f[m+1],v=oe(i,n,y,p);v.squaredDistance<g&&(g=v.squaredDistance,_=m+v.along)}g<r&&(r=g,u.ring&&e.targetIndex===d&&(u.endIndex>u.startIndex?_<u.startIndex&&(_+=f.length):u.endIndex<u.startIndex&&_>u.startIndex&&(_-=f.length)),a=_,o=d)}const h=e.targets[o];let l=h.ring;if(e.targetIndex===o&&l){const d=x(h.coordinates,a),u=t.getPixelFromCoordinate(d);ee(u,e.startPx)>s&&(l=!1)}if(l){const d=h.coordinates,u=d.length,f=h.startIndex,g=a;if(f<g){const _=S(d,f,g);S(d,f,g-u)<_&&(a-=u)}else{const _=S(d,f,g);S(d,f,g+u)<_&&(a+=u)}}return N.index=o,N.endIndex=a,N}function L(c,e,t,s){const i=c[0],n=c[1];for(let r=0,o=e.length-1;r<o;++r){const a=e[r],h=e[r+1],l=oe(i,n,a,h);if(l.squaredDistance===0){const d=r+l.along;s.push({coordinates:e,ring:t,startIndex:d,endIndex:d});return}}}const A={along:0,squaredDistance:0};function oe(c,e,t,s){const i=t[0],n=t[1],r=s[0],o=s[1],a=r-i,h=o-n;let l=0,d=i,u=n;return(a!==0||h!==0)&&(l=Pe(((c-i)*a+(e-n)*h)/(a*a+h*h),0,1),d+=a*l,u+=h*l),A.along=l,A.squaredDistance=xe(se(c,e,d,u),10),A}function x(c,e){const t=c.length;let s=Math.floor(e);const i=e-s;s>=t?s-=t:s<0&&(s+=t);let n=s+1;n>=t&&(n-=t);const r=c[s],o=r[0],a=r[1],h=c[n],l=h[0]-o,d=h[1]-a;return[o+l*i,a+d*i]}class qe extends z{constructor(e){const t=e;t.stopDown||(t.stopDown=Q),super(t),this.on,this.once,this.un,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=e.source?e.source:null,this.features_=e.features?e.features:null,this.snapTolerance_=e.snapTolerance?e.snapTolerance:12,this.type_=e.type,this.mode_=Be(this.type_),this.stopClick_=!!e.stopClick,this.minPoints_=e.minPoints?e.minPoints:this.mode_==="Polygon"?3:2,this.maxPoints_=this.mode_==="Circle"?2:e.maxPoints?e.maxPoints:1/0,this.finishCondition_=e.finishCondition?e.finishCondition:J,this.geometryLayout_=e.geometryLayout?e.geometryLayout:"XY";let s=e.geometryFunction;if(!s){const i=this.mode_;if(i==="Circle")s=function(n,r,o){const a=r||new Ne([NaN,NaN]),h=w(n[0],o),l=M(h,w(n[n.length-1],o));a.setCenterAndRadius(h,Math.sqrt(l),this.geometryLayout_);const d=q();return d&&a.transform(o,d),a};else{let n;i==="Point"?n=b:i==="LineString"?n=R:i==="Polygon"&&(n=te),s=function(r,o,a){return o?i==="Polygon"?r[0].length?o.setCoordinates([r[0].concat([r[0][0]])],this.geometryLayout_):o.setCoordinates([],this.geometryLayout_):o.setCoordinates(r,this.geometryLayout_):o=new n(r,this.geometryLayout_),o}}}this.geometryFunction_=s,this.dragVertexDelay_=e.dragVertexDelay!==void 0?e.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=e.clickTolerance?e.clickTolerance*e.clickTolerance:36,this.overlay_=new U({source:new B({useSpatialIndex:!1,wrapX:e.wrapX?e.wrapX:!1}),style:e.style?e.style:Ue(),updateWhileInteracting:!0}),this.geometryName_=e.geometryName,this.condition_=e.condition?e.condition:me,this.freehandCondition_,e.freehand?this.freehandCondition_=H:this.freehandCondition_=e.freehandCondition?e.freehandCondition:ye,this.traceCondition_,this.setTrace(e.trace||!1),this.traceState_={active:!1},this.traceSource_=e.traceSource||e.source||null,this.addChangeListener(pe.ACTIVE,this.updateState_)}setTrace(e){let t;e?e===!0?t=H:t=e:t=Ce,this.traceCondition_=t}setMap(e){super.setMap(e),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(e){e.originalEvent.type===Z.CONTEXTMENU&&e.originalEvent.preventDefault(),this.freehand_=this.mode_!=="Point"&&this.freehandCondition_(e);let t=e.type===C.POINTERMOVE,s=!0;return!this.freehand_&&this.lastDragTime_&&e.type===C.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=e.pixel,this.shouldHandle_=!this.freehand_,t=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_!==void 0&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&e.type===C.POINTERDRAG&&this.sketchFeature_!==null?(this.addToDrawing_(e.coordinate),s=!1):this.freehand_&&e.type===C.POINTERDOWN?s=!1:t&&this.getPointerCount()<2?(s=e.type===C.POINTERMOVE,s&&this.freehand_?(this.handlePointerMove_(e),this.shouldHandle_&&e.originalEvent.preventDefault()):(e.originalEvent.pointerType==="mouse"||e.type===C.POINTERDRAG&&this.downTimeout_===void 0)&&this.handlePointerMove_(e)):e.type===C.DBLCLICK&&(s=!1),super.handleEvent(e)&&s}handleDownEvent(e){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=e.pixel,this.finishCoordinate_||this.startDrawing_(e.coordinate),!0):this.condition_(e)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new we(C.POINTERMOVE,e.map,e.originalEvent,!1,e.frameState))},this.dragVertexDelay_),this.downPx_=e.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(e){if(!this.traceSource_||!this.traceCondition_(e))return;if(this.traceState_.active){this.deactivateTrace_();return}const t=this.getMap(),s=t.getCoordinateFromPixel([e.pixel[0]-this.snapTolerance_,e.pixel[1]+this.snapTolerance_]),i=t.getCoordinateFromPixel([e.pixel[0]+this.snapTolerance_,e.pixel[1]-this.snapTolerance_]),n=G([s,i]),r=this.traceSource_.getFeaturesInExtent(n);if(r.length===0)return;const o=Ae(e.coordinate,r);o.length&&(this.traceState_={active:!0,startPx:e.pixel.slice(),targets:o,targetIndex:-1})}addOrRemoveTracedCoordinates_(e,t){const s=e.startIndex<=e.endIndex,i=e.startIndex<=t;s===i?s&&t>e.endIndex||!s&&t<e.endIndex?this.addTracedCoordinates_(e,e.endIndex,t):(s&&t<e.endIndex||!s&&t>e.endIndex)&&this.removeTracedCoordinates_(t,e.endIndex):(this.removeTracedCoordinates_(e.startIndex,e.endIndex),this.addTracedCoordinates_(e,e.startIndex,t))}removeTracedCoordinates_(e,t){if(e===t)return;let s=0;if(e<t){const i=Math.ceil(e);let n=Math.floor(t);n===t&&(n-=1),s=n-i+1}else{const i=Math.floor(e);let n=Math.ceil(t);n===t&&(n+=1),s=i-n+1}s>0&&this.removeLastPoints_(s)}addTracedCoordinates_(e,t,s){if(t===s)return;const i=[];if(t<s){const n=Math.ceil(t);let r=Math.floor(s);r===s&&(r-=1);for(let o=n;o<=r;++o)i.push(T(e.coordinates,o))}else{const n=Math.floor(t);let r=Math.ceil(s);r===s&&(r+=1);for(let o=n;o>=r;--o)i.push(T(e.coordinates,o))}i.length&&this.appendCoordinates(i)}updateTrace_(e){const t=this.traceState_;if(!t.active||t.targetIndex===-1&&ee(t.startPx,e.pixel)<this.snapTolerance_)return;const s=Ve(e.coordinate,t,this.getMap(),this.snapTolerance_);if(t.targetIndex!==s.index){if(t.targetIndex!==-1){const a=t.targets[t.targetIndex];this.removeTracedCoordinates_(a.startIndex,a.endIndex)}const o=t.targets[s.index];this.addTracedCoordinates_(o,o.startIndex,s.endIndex)}else{const o=t.targets[t.targetIndex];this.addOrRemoveTracedCoordinates_(o,s.endIndex)}t.targetIndex=s.index;const i=t.targets[t.targetIndex];i.endIndex=s.endIndex;const n=x(i.coordinates,i.endIndex),r=this.getMap().getPixelFromCoordinate(n);e.coordinate=n,e.pixel=[Math.round(r[0]),Math.round(r[1])]}handleUpEvent(e){let t=!0;if(this.getPointerCount()===0){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(e);const s=this.traceState_.active;if(this.toggleTraceState_(e),this.shouldHandle_){const i=!this.finishCoordinate_;i&&this.startDrawing_(e.coordinate),!i&&this.freehand_?this.finishDrawing():!this.freehand_&&(!i||this.mode_==="Point")&&(this.atFinish_(e.pixel,s)?this.finishCondition_(e)&&this.finishDrawing():this.addToDrawing_(e.coordinate)),t=!1}else this.freehand_&&this.abortDrawing()}return!t&&this.stopClick_&&e.preventDefault(),t}handlePointerMove_(e){if(this.pointerType_=e.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const t=this.downPx_,s=e.pixel,i=t[0]-s[0],n=t[1]-s[1],r=i*i+n*n;if(this.shouldHandle_=this.freehand_?r>this.squaredClickTolerance_:r<=this.squaredClickTolerance_,!this.shouldHandle_)return}if(!this.finishCoordinate_){this.createOrUpdateSketchPoint_(e.coordinate.slice());return}this.updateTrace_(e),this.modifyDrawing_(e.coordinate)}atFinish_(e,t){let s=!1;if(this.sketchFeature_){let i=!1,n=[this.finishCoordinate_];const r=this.mode_;if(r==="Point")s=!0;else if(r==="Circle")s=this.sketchCoords_.length===2;else if(r==="LineString")i=!t&&this.sketchCoords_.length>this.minPoints_;else if(r==="Polygon"){const o=this.sketchCoords_;i=o[0].length>this.minPoints_,n=[o[0][0],o[0][o[0].length-2]],t?n=[o[0][0]]:n=[o[0][0],o[0][o[0].length-2]]}if(i){const o=this.getMap();for(let a=0,h=n.length;a<h;a++){const l=n[a],d=o.getPixelFromCoordinate(l),u=e[0]-d[0],f=e[1]-d[1],g=this.freehand_?1:this.snapTolerance_;if(s=Math.sqrt(u*u+f*f)<=g,s){this.finishCoordinate_=l;break}}}}return s}createOrUpdateSketchPoint_(e){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(e):(this.sketchPoint_=new k(new b(e)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(e){this.sketchLine_||(this.sketchLine_=new k);const t=e.getLinearRing(0);let s=this.sketchLine_.getGeometry();s?(s.setFlatCoordinates(t.getLayout(),t.getFlatCoordinates()),s.changed()):(s=new R(t.getFlatCoordinates(),t.getLayout()),this.sketchLine_.setGeometry(s))}startDrawing_(e){const t=this.getMap().getView().getProjection(),s=W(this.geometryLayout_);for(;e.length<s;)e.push(0);this.finishCoordinate_=e,this.mode_==="Point"?this.sketchCoords_=e.slice():this.mode_==="Polygon"?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new k(new R(this.sketchLineCoords_)));const i=this.geometryFunction_(this.sketchCoords_,void 0,t);this.sketchFeature_=new k,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new D(F.DRAWSTART,this.sketchFeature_))}modifyDrawing_(e){const t=this.getMap(),s=this.sketchFeature_.getGeometry(),i=t.getView().getProjection(),n=W(this.geometryLayout_);let r,o;for(;e.length<n;)e.push(0);this.mode_==="Point"?o=this.sketchCoords_:this.mode_==="Polygon"?(r=this.sketchCoords_[0],o=r[r.length-1],this.atFinish_(t.getPixelFromCoordinate(e))&&(e=this.finishCoordinate_.slice())):(r=this.sketchCoords_,o=r[r.length-1]),o[0]=e[0],o[1]=e[1],this.geometryFunction_(this.sketchCoords_,s,i),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(e),s.getType()==="Polygon"&&this.mode_!=="Polygon"?this.createOrUpdateCustomSketchLine_(s):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(e){const t=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection();let i,n;const r=this.mode_;r==="LineString"||r==="Circle"?(this.finishCoordinate_=e.slice(),n=this.sketchCoords_,n.length>=this.maxPoints_&&(this.freehand_?n.pop():i=!0),n.push(e.slice()),this.geometryFunction_(n,t,s)):r==="Polygon"&&(n=this.sketchCoords_[0],n.length>=this.maxPoints_&&(this.freehand_?n.pop():i=!0),n.push(e.slice()),i&&(this.finishCoordinate_=n[0]),this.geometryFunction_(this.sketchCoords_,t,s)),this.createOrUpdateSketchPoint_(e.slice()),this.updateSketchFeatures_(),i&&this.finishDrawing()}removeLastPoints_(e){if(!this.sketchFeature_)return;const t=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection(),i=this.mode_;for(let n=0;n<e;++n){let r;if(i==="LineString"||i==="Circle"){if(r=this.sketchCoords_,r.splice(-2,1),r.length>=2){this.finishCoordinate_=r[r.length-2].slice();const o=this.finishCoordinate_.slice();r[r.length-1]=o,this.createOrUpdateSketchPoint_(o)}this.geometryFunction_(r,t,s),t.getType()==="Polygon"&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(t)}else if(i==="Polygon"){r=this.sketchCoords_[0],r.splice(-2,1);const o=this.sketchLine_.getGeometry();if(r.length>=2){const a=r[r.length-2].slice();r[r.length-1]=a,this.createOrUpdateSketchPoint_(a)}o.setCoordinates(r),this.geometryFunction_(this.sketchCoords_,t,s)}if(r.length===1){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const e=this.abortDrawing_();if(!e)return;let t=this.sketchCoords_;const s=e.getGeometry(),i=this.getMap().getView().getProjection();this.mode_==="LineString"?(t.pop(),this.geometryFunction_(t,s,i)):this.mode_==="Polygon"&&(t[0].pop(),this.geometryFunction_(t,s,i),t=s.getCoordinates()),this.type_==="MultiPoint"?e.setGeometry(new Oe([t])):this.type_==="MultiLineString"?e.setGeometry(new ie([t])):this.type_==="MultiPolygon"&&e.setGeometry(new ne([t])),this.dispatchEvent(new D(F.DRAWEND,e)),this.features_&&this.features_.push(e),this.source_&&this.source_.addFeature(e)}abortDrawing_(){this.finishCoordinate_=null;const e=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),e}abortDrawing(){const e=this.abortDrawing_();e&&this.dispatchEvent(new D(F.DRAWABORT,e))}appendCoordinates(e){const t=this.mode_,s=!this.sketchFeature_;s&&this.startDrawing_(e[0]);let i;if(t==="LineString"||t==="Circle")i=this.sketchCoords_;else if(t==="Polygon")i=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[];else return;s&&i.shift(),i.pop();for(let r=0;r<e.length;r++)this.addToDrawing_(e[r]);const n=e[e.length-1];this.addToDrawing_(n),this.modifyDrawing_(n)}extend(e){const s=e.getGeometry();this.sketchFeature_=e,this.sketchCoords_=s.getCoordinates();const i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.sketchPoint_=new k(new b(i)),this.updateSketchFeatures_(),this.dispatchEvent(new D(F.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const e=[];this.sketchFeature_&&e.push(this.sketchFeature_),this.sketchLine_&&e.push(this.sketchLine_),this.sketchPoint_&&e.push(this.sketchPoint_);const t=this.overlay_.getSource();t.clear(!0),t.addFeatures(e)}updateState_(){const e=this.getMap(),t=this.getActive();(!e||!t)&&this.abortDrawing(),this.overlay_.setMap(t?e:null)}}function Ue(){const c=je();return function(e,t){return c[e.getGeometry().getType()]}}function Be(c){switch(c){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+c)}}const Ke=qe;function $(c){if(c.feature)return c.feature;if(c.element)return c.element}const V=[];class He extends z{constructor(e){e=e||{};const t=e;t.handleDownEvent||(t.handleDownEvent=J),t.stopDown||(t.stopDown=Q),super(t),this.source_=e.source?e.source:null,this.vertex_=e.vertex!==void 0?e.vertex:!0,this.edge_=e.edge!==void 0?e.edge:!0,this.features_=e.features?e.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.rBush_=new Ie,this.GEOMETRY_SEGMENTERS_={Point:this.segmentPointGeometry_.bind(this),LineString:this.segmentLineStringGeometry_.bind(this),LinearRing:this.segmentLineStringGeometry_.bind(this),Polygon:this.segmentPolygonGeometry_.bind(this),MultiPoint:this.segmentMultiPointGeometry_.bind(this),MultiLineString:this.segmentMultiLineStringGeometry_.bind(this),MultiPolygon:this.segmentMultiPolygonGeometry_.bind(this),GeometryCollection:this.segmentGeometryCollectionGeometry_.bind(this),Circle:this.segmentCircleGeometry_.bind(this)}}addFeature(e,t){t=t!==void 0?t:!0;const s=O(e),i=e.getGeometry();if(i){const n=this.GEOMETRY_SEGMENTERS_[i.getType()];if(n){this.indexedFeaturesExtents_[s]=i.getExtent(ke());const r=[];if(n(r,i),r.length===1)this.rBush_.insert(G(r[0]),{feature:e,segment:r[0]});else if(r.length>1){const o=r.map(h=>G(h)),a=r.map(h=>({feature:e,segment:h}));this.rBush_.load(o,a)}}}t&&(this.featureChangeListenerKeys_[s]=P(e,Z.CHANGE,this.handleFeatureChange_,this))}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t&&(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel),super.handleEvent(e)}handleFeatureAdd_(e){const t=$(e);this.addFeature(t)}handleFeatureRemove_(e){const t=$(e);this.removeFeature(t)}handleFeatureChange_(e){const t=e.target;if(this.handlingDownUpSequence){const s=O(t);s in this.pendingFeatures_||(this.pendingFeatures_[s]=t)}else this.updateFeature_(t)}handleUpEvent(e){const t=Object.values(this.pendingFeatures_);return t.length&&(t.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1}removeFeature(e,t){const s=t!==void 0?t:!0,i=O(e),n=this.indexedFeaturesExtents_[i];if(n){const r=this.rBush_,o=[];r.forEachInExtent(n,function(a){e===a.feature&&o.push(a)});for(let a=o.length-1;a>=0;--a)r.remove(o[a])}s&&(j(this.featureChangeListenerKeys_[i]),delete this.featureChangeListenerKeys_[i])}setMap(e){const t=this.getMap(),s=this.featuresListenerKeys_,i=this.getFeatures_();t&&(s.forEach(j),s.length=0,this.rBush_.clear(),Object.values(this.featureChangeListenerKeys_).forEach(j),this.featureChangeListenerKeys_={}),super.setMap(e),e&&(this.features_?s.push(P(this.features_,X.ADD,this.handleFeatureAdd_,this),P(this.features_,X.REMOVE,this.handleFeatureRemove_,this)):this.source_&&s.push(P(this.source_,Y.ADDFEATURE,this.handleFeatureAdd_,this),P(this.source_,Y.REMOVEFEATURE,this.handleFeatureRemove_,this)),i.forEach(n=>this.addFeature(n)))}snapTo(e,t,s){const i=s.getView().getProjection(),n=w(t,i),r=Fe(De(G([n]),s.getView().getResolution()*this.pixelTolerance_),i),o=this.rBush_.getInExtent(r),a=o.length;if(a===0)return null;let h,l=1/0;const d=this.pixelTolerance_*this.pixelTolerance_,u=()=>{if(h){const f=s.getPixelFromCoordinate(h);if(M(e,f)<=d)return{vertex:h,vertexPixel:[Math.round(f[0]),Math.round(f[1])]}}return null};if(this.vertex_){for(let g=0;g<a;++g){const _=o[g];_.feature.getGeometry().getType()!=="Circle"&&_.segment.forEach(m=>{const y=w(m,i),p=M(n,y);p<l&&(h=m,l=p)})}const f=u();if(f)return f}if(this.edge_){for(let g=0;g<a;++g){let _=null;const m=o[g];if(m.feature.getGeometry().getType()==="Circle"){let y=m.feature.getGeometry();const p=q();p&&(y=y.clone().transform(p,i)),_=Ee(n,y)}else{const[y,p]=m.segment;p&&(V[0]=w(y,i),V[1]=w(p,i),_=Se(n,V))}if(_){const y=M(n,_);y<l&&(h=Le(_,i),l=y)}}const f=u();if(f)return f}return null}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}segmentCircleGeometry_(e,t){const s=this.getMap().getView().getProjection();let i=t;const n=q();n&&(i=i.clone().transform(n,s));const r=Me(i);n&&r.transform(s,n);const o=r.getCoordinates()[0];for(let a=0,h=o.length-1;a<h;++a)e.push(o.slice(a,a+2))}segmentGeometryCollectionGeometry_(e,t){const s=t.getGeometriesArray();for(let i=0;i<s.length;++i){const n=this.GEOMETRY_SEGMENTERS_[s[i].getType()];n&&n(e,s[i])}}segmentLineStringGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length-1;i<n;++i)e.push(s.slice(i,i+2))}segmentMultiLineStringGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length-1;o<a;++o)e.push(r.slice(o,o+2))}}segmentMultiPointGeometry_(e,t){t.getCoordinates().forEach(s=>{e.push([s])})}segmentMultiPolygonGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length;o<a;++o){const h=r[o];for(let l=0,d=h.length-1;l<d;++l)e.push(h.slice(l,l+2))}}}segmentPointGeometry_(e,t){e.push([t.getCoordinates()])}segmentPolygonGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length-1;o<a;++o)e.push(r.slice(o,o+2))}}}const We=He,K=new U({source:new B({format:new be,url:"../data/geojson/fire.json"}),style:{"fill-color":"rgba(255, 0, 0, 0.3)","stroke-color":"rgba(255, 0, 0, 0.9)","stroke-width":2}}),ae=new U({source:new B,style:{"stroke-color":"rgba(100, 255, 0, 1)","stroke-width":3,"fill-color":"rgba(100, 255, 0, 0.3)"}}),he=new Ge({layers:[K,ae],target:"map",view:new Re({center:[-13378949,5943751],zoom:11})}),Xe=new We({source:K.getSource()}),Ye=new Ke({type:"Polygon",source:ae.getSource(),trace:!0,traceSource:K.getSource(),style:{"stroke-color":"rgba(255, 255, 100, 0.5)","stroke-width":1.5,"fill-color":"rgba(255, 255, 100, 0.25)","circle-radius":6,"circle-fill-color":"rgba(255, 255, 100, 0.5)"}});he.addInteraction(Ye);he.addInteraction(Xe);
